<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Operation 500-pound Parakeet</title>
    <link>http://replace-this-with-your-hugo-site.com/</link>
    <description>Recent content on Operation 500-pound Parakeet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All articless written by Balazs Nagy. I might not share the viewpoints of my employer.</copyright>
    <lastBuildDate>Tue, 28 Jun 2016 09:29:41 +0200</lastBuildDate>
    <atom:link href="http://replace-this-with-your-hugo-site.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Plan for Goiardi</title>
      <link>http://replace-this-with-your-hugo-site.com/post/plan-for-goiardi/</link>
      <pubDate>Tue, 28 Jun 2016 09:29:41 +0200</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/post/plan-for-goiardi/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;m building docker containers. I&amp;rsquo;ve built a couple already: GitLab CE, PowerDNS, TeamSpeak3, Youtrack, Perforce (it&amp;rsquo;s called Helix Versioning Engine nowadays), and as you might figured out, Goiardi.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not totally happy with building images though.&lt;/p&gt;

&lt;p&gt;Building a docker image creates a lot of layers, for, hmm, &lt;em&gt;nothing in particular&lt;/em&gt;. However, It also creates a lot of hidden dependencies, like keeping build dependencies in runtime.&lt;/p&gt;

&lt;p&gt;A lot of Dockerfiles start with downloading &lt;code&gt;curl&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt; to fetch dependencies. They don&amp;rsquo;t check downloaded files&amp;rsquo; integrity. Sometimes they get rid of the downloader utilities though.&lt;/p&gt;

&lt;p&gt;Dockerfiles have no notions for tagging, uploading, versioning, even though they keep track of all input versions.&lt;/p&gt;

&lt;p&gt;I even went on writing my not so difficult dockerfile builder to handle artifacts, files, and templating separately.&lt;/p&gt;

&lt;p&gt;However, what I really wanted is a separate build environment.&lt;/p&gt;

&lt;h2 id=&#34;enter-habitat&#34;&gt;Enter Habitat&lt;/h2&gt;

&lt;p&gt;Adam Jacob felt the same pain, and he took a more drastic approach: he started building Habitat, which takes the care of building, distributing, configuring, managing, and clustering completely independent applications.&lt;/p&gt;

&lt;h3 id=&#34;building-by-the-plan&#34;&gt;Building by the plan&lt;/h3&gt;

&lt;p&gt;Habitat does all the build in a separated environment called Studio. It allows you to download, check integrity, unpack, compile, and install. It handles dependencies for both build and run time, and allows you to template configurations. Output name and version is also well defined.&lt;/p&gt;

&lt;p&gt;This all goes to a plan. A well-defined, versionable, easy to understand plan.&lt;/p&gt;

&lt;h3 id=&#34;create-invent-make-a-mess&#34;&gt;Create, Invent, Make a mess&lt;/h3&gt;

&lt;p&gt;The fact Studio runs in a docker instance has other benefits. Your plan directory is mounted as &lt;code&gt;/src&lt;/code&gt; in Studio, so you can use your favorite editor, while you can make a chaos. If you feel you&amp;rsquo;ve blown everything up, just throw the old Studio away, and create a new one.&lt;/p&gt;

&lt;h3 id=&#34;slim-results&#34;&gt;Slim results&lt;/h3&gt;

&lt;p&gt;In Docker, it doesn&amp;rsquo;t really matter which OS you&amp;rsquo;re using on the desktop, so you can use which you&amp;rsquo;re the most comfortable with (think of Docker for Windows / Docker for Mac). Then, you can choose another OS at server side. I mean a linux distro&amp;rsquo;s tooling.&lt;/p&gt;

&lt;p&gt;Habitat breaks these rules: why do you need an OS if you don&amp;rsquo;t use it? Habitat takes care of all dependencies, starting from GLIBC to unix commands, interpreters. Just what&amp;rsquo;s needed, and nothing else. It also edits executables, to use exact library versions.&lt;/p&gt;

&lt;p&gt;When you build a docker image of a Habitat package, it adds a very slim layer of linux tools though, a busybox image. Results are very small. My goiardi docker instance is 174MB (as a comparison, my ubuntu-based docker instance is 354MB, executable is 16MB, the habitat package file is 3.2MB). This is not that bad, given glibc, gcc-libs, and openssl take 135MB.&lt;/p&gt;

&lt;h3 id=&#34;manage-configurations&#34;&gt;Manage configurations&lt;/h3&gt;

&lt;p&gt;Templates allow us to fine-tune configurations. It allows modifying configs at start time, at run time, when clustering changes, when bound services change. Everything is handled by the Supervisor, which monitors our applications.&lt;/p&gt;

&lt;p&gt;Nothing is hidden though: clustering and bindings have to be added to the templates. Hooks can handle events like files uploaded, reconfiguration, even inquiring health checks.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>