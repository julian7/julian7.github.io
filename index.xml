<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Operation 500-pound Parakeet</title>
    <link>https://julian7.github.io/</link>
    <description>Recent content on Operation 500-pound Parakeet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All articless written by Balazs Nagy. I might not share the viewpoints of my employer.</copyright>
    <lastBuildDate>Tue, 28 Jun 2016 09:29:41 +0200</lastBuildDate>
    <atom:link href="https://julian7.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Good Plan for building containers</title>
      <link>https://julian7.github.io/post/plan-for-containers/</link>
      <pubDate>Tue, 28 Jun 2016 09:29:41 +0200</pubDate>
      
      <guid>https://julian7.github.io/post/plan-for-containers/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;m building docker containers. I&amp;rsquo;ve built a couple already: GitLab CE, PowerDNS, TeamSpeak3, Youtrack, Perforce (it&amp;rsquo;s called Helix Versioning Engine nowadays), and Goiardi.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not totally happy with building images though.&lt;/p&gt;

&lt;p&gt;Building a docker image creates a lot of layers, for, hmm, &lt;em&gt;nothing in particular&lt;/em&gt;. However, It also creates a lot of hidden dependencies, like keeping build dependencies in runtime. It can be worse though: when a new layer removes build dependencies. It&amp;rsquo;s not there, yet you have to download it.&lt;/p&gt;

&lt;p&gt;A lot of Dockerfiles start with downloading &lt;code&gt;curl&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt; to fetch dependencies. They don&amp;rsquo;t check downloaded files&amp;rsquo; integrity. Sometimes they get rid of the downloader utilities though, usually as a new layer.&lt;/p&gt;

&lt;p&gt;Dockerfile has no notion for tagging, uploading, versioning, even though it keeps track of all input versions.&lt;/p&gt;

&lt;p&gt;I even went on writing my not so difficult dockerfile builder to handle artifacts, files, and templating separately.&lt;/p&gt;

&lt;p&gt;However, what I really wanted is a separate build environment.&lt;/p&gt;

&lt;h2 id=&#34;enter-habitat&#34;&gt;Enter Habitat&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/adamhjk&#34;&gt;Adam Jacob&lt;/a&gt; felt the same pain, and he took a more drastic approach: he started building Habitat, which takes the care of building, distributing, configuring, managing, and clustering completely independent applications.&lt;/p&gt;

&lt;h3 id=&#34;building-by-the-plan&#34;&gt;Building by the plan&lt;/h3&gt;

&lt;p&gt;Habitat does all the build in a separated environment called Studio. It allows you to download, check integrity, unpack, compile, and install artifacts. It handles dependencies for both build and run time, and allows you to template configurations. Output name and version is also well defined.&lt;/p&gt;

&lt;p&gt;This all goes to a plan. A well-defined, versionable, easy to understand plan.&lt;/p&gt;

&lt;h3 id=&#34;create-invent-make-a-mess&#34;&gt;Create, Invent, Make a mess&lt;/h3&gt;

&lt;p&gt;The fact Studio runs in a docker instance has other benefits. Your plan directory is mounted as &lt;code&gt;/src&lt;/code&gt; in Studio, so you can use your favorite editor, while you can &lt;del&gt;rise entropy level&lt;/del&gt; explore through the build process. If you feel you&amp;rsquo;ve blown everything up, just throw the old Studio away, and create a new one.&lt;/p&gt;

&lt;h3 id=&#34;slim-results&#34;&gt;Slim results&lt;/h3&gt;

&lt;p&gt;In Docker, it doesn&amp;rsquo;t really matter which OS you&amp;rsquo;re using on the desktop, so you can use which you&amp;rsquo;re the most comfortable with (think of Docker for Windows / Docker for Mac). Then, you can choose another OS at server side. I mean a linux distro&amp;rsquo;s tooling.&lt;/p&gt;

&lt;p&gt;Habitat breaks these rules: why do you need an OS if you don&amp;rsquo;t use it? Habitat takes care of all dependencies, starting from GLIBC to unix commands, interpreters. Just what&amp;rsquo;s needed, and nothing else.&lt;/p&gt;

&lt;p&gt;When you build a docker image of a Habitat package, it adds a very slim layer of linux tools though: a busybox image. Results are very small. My goiardi docker instance is 174MB (as a comparison, my ubuntu-based docker instance is 354MB, executable is 16MB, all the others are dependencies: glibc, gcc-libs, and openssl take 135MB).&lt;/p&gt;

&lt;h3 id=&#34;manage-configurations&#34;&gt;Manage configurations&lt;/h3&gt;

&lt;p&gt;Templates allow us to fine-tune configurations. It allows modifying configs at start time, at run time, when clustering changes, when bound services change. Everything is handled by the Supervisor, which monitors our applications.&lt;/p&gt;

&lt;p&gt;Nothing is hidden though: clustering and bindings have to be added to the templates. Hooks can handle events like files uploaded, reconfiguration, even inquiring health checks.&lt;/p&gt;

&lt;h3 id=&#34;gives-way-to-orchestration-systems&#34;&gt;Gives way to orchestration systems&lt;/h3&gt;

&lt;p&gt;While Habitat has tight control on configuration and service discovery, it is also polite enough not to mess with scheduling, volume management, and other tasks. There are very good products which solve these issues very well. It is also not descriptive: you can run a habitat package directly, or using Mesos, or using a Docker / ACI scheduler.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m excited. It fixes problems I feel myself, with a level of purity and elegance I admire. I&amp;rsquo;m looking forward publishing my plans.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>